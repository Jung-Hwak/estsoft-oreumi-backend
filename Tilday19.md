# 오늘 배운 내용

## Java

### 정적 팩토리 메서드 패턴

1. 정적 팩토리 메서드 패턴
   - 정적 메서드를 통해 간접적으로 객체를 생성하는 디자인 패턴
   - 개발자들이 코드를 작성할때 코드의 가독성을 높이기 위해 만들어 짐.
   - 정적 팩토리 메서드를 이용해 생성자를 한번더 감싸놓은 듯한 느낌이다.(가독성을 높이기 위해)
2. 정적 팩토리 메서드
   - `from` - Date.from(instant) : 자료형이 다른 객체를 전달받아, 이를 변환해서 새로운 객체를 생성해서 반환한다.
   - `of` - List.of(1, 2, 3) : 여러 인자를 전달받아 객체를 생성해서 반환한다.
   - `valueOf` - Integer.valueOf(10) : 특정 값(원시 자료형, 문자열 등)으로 객체를 생성해서 반환한다.
   - `getInstance` - StackWalker.getInstance(options) : 싱글톤 패턴 등에서 인스턴스를 생성해서 반환하거나 이전에 생성한 인스턴스를 반환한다.
   - `newInstance` - Array.newInstance(object, length) : 새로운 인스턴스를 생성해서 반환한다.

### Java Record

- 클래스의 한 종류 이며, 특정한 데이터를 표현하기 위한 객체를 만들기 위한 클래스가 Record이다.
- Java 14에서 Preview로 처음 공개됐고 Java 16에서 정식으로 도입됐다.
- class키워드 대신 record 를 넣어주고 식별자 뒤에(int x, int y) 컴포넌트를 정의하고, 필드로서 괄호안에 추가되고 final로 정의 된다.
- 레코드는 불변 객체이고, 추상 클래스로 선언할 수 없으며, 묵시적으로 final로 선언돼 상속할 수 없다. 
- 레코드에서는 표준 생성자가 자동으로 추가가 된다.
- 레코드의 컴포넌트로 상수 필드가 정의되기 때문에 생성자에서 반드시 초기화를 해줘야한다.
- 레코드는 불변성을 유지하는 데이터 객체 이므로 비즈니스 로직을 레코드에 포함시키는 것은 부적절하다.
1. Java Record의 컴팩트 생성자
   - 레코드에서 생성자를 간결하게 정의하는 방식
   - 생성자의 매개 변수 목록과 필드의 초기화 표현식을 저장한다.
   - 주로 매개 변수를 검증하거나, 값을 규정화 하기 위해 사용한다. 
2. Java Record의 접근자
   - 레코드의 필드는 private 멤버로 선언되어 되므로 private 멤버로 선언된다.
   - 자동으로 추가되는 레코드의 접근자는 전통적인 접근자 명명 규칙인 "getXXX" 대신 식별자를 그대로 사용한다.
* Java Record 를 사용할때 주의점
  - 레코드는 불변 객체이다
  - 레코드에는 비즈니스 로직을 작성하지 않는다.
  - 특별한 이유가 있는 게 아니라면 자동으로 추가된 메서드를 사용한다.
  - 사용할 Java 버전을 확인해야한다. (Java 14에서 처음 공개 되어 16에 정식도입 되었기 때문) 

### 내부 클래스

- 클래스 내부에서 정의한 클래스를 말한다(중첩 클래스)
- 내부 클래스는 두 클래스가 긴밀한 관계에 있거나 어떤 클래스나 메서드에서만 사용하는 클래스인 경우에 사용한다.
- 하나의 파일 내에서 내부 클래스와 외부 클래스를 사용할 수 있어 유지 보수가 좋아진다.
- 내부 클래스에서 static를 붙이지 않으면 인스턴스 내부 클래스가 되고 static 가 붙으면 정적 내부 클래스가되고,
- 어떤 지역에서 정의하면 지역 내부 클래스가 되고, 딱 한번만 객체를 생성하고 말거면 익명 내부 클래스가 된다.
1. 인스턴스 내부 클래스
   - 외부 클래스의 인스턴스가 생성이된 이후에 인스턴스 내부 클래스가 정의된다.
   - 인스턴스 내부 클래스는 정적 멤버들을 사용할 수 없지만 정적 상수는 상수 필드이므로 사용이 가능하다.
2. 정적 내부 클래스
   - 어떤 클래스 내에서 static을 붙여 정적 내부 클래스를 정의할 수 있다.
   - 인스턴스 내부 클래스 보다는 메모리 효율이 좋다, 웬만하면 정적 내부 클래스로 선언하는게 좋다.
   - 정적 내부 클레스에서는 외부 클래스의 적정 멤버에게만 접근할 수 있다. 
3. 지역 내부 클래스
   - 메서드 본채에서 정의한 클래스들을 지역 내부 클래스 라고 한다.
   - 지역 변수처럼 메서드 본체에서만 한정적으로 쓰인다.
   - 접근 제어 지시자와 static 키워드를 붙일 수 없다.
   - 외부 클래스의 메서드에서 선언한 지역 변수를 변경할 수 없다. 
4. 익명 내부 클래스
   - 메서드 내에서 기존의 어떤 클래스를 딱 한번 재정의 하기 위해 사용한다.
   - 클래스를 정의하는 것과 동시에 객체를 생성하기 위한, 이름이 없는 클래스이다.
   - 익명 내부 클래스에서는 생성자가 없다.

### 빌더 패턴

- 객체의 생성 과정과 표현 방법을 분리해서 구성이 다양한 인스턴스를 생성하는 패턴이다.
- 어떤 클래스의 필드가 많으면 매개 변수가 그만큼 존재하는데

### 함수형 프로그래밍(인터페이스)

* 함수형 프로그래밍의 주요 특징
  1. 순수 함수
     - 동일한 입력에 대해 항상 동일한 결과를 반환하고, 외부의 부수효과가 없는 함수를 말한다.
     - 순수 함수를 호출하면 프로그램에 어던 변화도 없고, 입력 값에 대한 결과를 예상할 수 있어 테스트 하기 쉽다.
  2. 불변성
     - 데이터의 원본은 절대 변하지 않는다.
  3. 1급 객체
     - 함수를 값으로 취급해서 변수에 할당하거나, 인자로 전달하거나 반환 값으로 사용할 수 있다
  4. 고차함수
     - 다른 함수를 인자로 받거나 반환 값으로 내놓을 수 있다.
  5. 익명 함수
     - 이름이 없는 함수를 익명 함수라고 한다.
  6. 참조 투명성
     - 함수의 호출을 결과값(반환 값) 으로 대체할수 있다. 

* 부수 효과와 순수 함수
1. 부수 효과
   - 부수 효과란 다음과 같은 변화 또는 변화가 발생하는 작업을 의미한다.
     - 자료 구조나 변수, 객체 필드의 값이 변경됨
     - 예외나 오류가 발생하며 실행이 중단됨
     - 콘솔 입출력 또는 파일 입출력이 발생함
2. 순수 함수
   - 부수 효과를 제거하고, 동일한 입력에 대해 항상 동일한 결과를 반환하는 함수
     - 메모리나 입출력의 관점에서 부수 효과가 없는 함수
     - 함수의 실행이 외부에 영향을 끼치지 않는 함수
     - 사이드 이펙트가 없도록 만들어 지는게 `순수 함수` 라고 한다.
3. 순수 함수의 장접
   - 함수가 독립적이고 부수 효과가 없기 때문에 스레드에 안정성을 보장받는다.
   - 스레드에 안정성을 보장받아 병렬 처리를 동기화 없이 진행할 수 있다.

* 프로그래밍 패러다임
  - 프로그래밍 패러 다임은 프로그램을 어떻게 작성할 것 이냐.
* 명령형 프로그래밍
  - 문제를 어떻게 해결할 것인지 설명하는 방법.
  - 객체 지향 프로그래밍과 절차 지향 프로그래밍이 명령형 프로그래밍이다.
* 선언형 프로그래밍
  - 어떻게 할것인지 보다 무엇을 할 것인지 설명하는 방법
  - 함수형 프로그래밍이 대표적인 선언형 프로그래밍이다.

1. 함수형 프로그래밍
   -  자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변데이터를 멀리하는 프로그래밍 패러다임의 하나
   -  함수형 프로그래밍에서 만들어지는 작성하는 함수들을 람다 표현식, (람다 함수, 람다식)라고 표현한다.

2. 람다 표현식
   - 메서드를 표현식으로 작성해서 객체를 만드는걸 람다 표현식이라고 한다
   - 람다 표현식으로 표현하면 식별자와 반환 값 자료형이 없어져서, 람다 표현식을 익명 함수라고도 한다.
   - 매개 변수 목록은 괄호로 묶고, 메서드 본체는 중괄호({})로 묶는다.
   - 메서드 본체의 문장이 하나이면 중괄호와 세미콜론을 생략할 수 있다.
   - 주로 한 번만 사용하거나 함수를 인자로 전달해야 하는 경우에 유용하게 사용된다.(일회성)
   * 매개 변수가 하나이면 괄호를 생략 할수 있다.
   * 매개 변수가 없으면 괄호를 생략할 수 없다.  
    ```
    int square(int x) { return x * x; }
    Function<Integer, Integer> square = (Integer x) -> { return x * x; }; 
    Function<Integer, Integer> square = (x) -> x * x;
    Function<Integer, Integer> square = x -> x * x;

### Java Stream API

* Java Stream API
  - 스트림(Stream)은 "데이터의 연속적인 흐름"을 말한다.
  - Java Stream API는 "데이터의 연속적인 흐름"을 표준화된 방법으로 쉽게 처리할 수 있도록 지원하는 클래스의 집합이다.
  - for 구문이나 while 구문을 사용해야하는 기존 반복문을 대체할 수 있어. 코드 가독성이 좋아진다.
  - 병렬 처리를 쉽게 할 수 있어서 처리 속도를 높일 수 있다.
* 스트림 파이프(Stream pipeline) 라인
  - 스트림 파이프라인은 데이터를 처리하는 과정을 말한다, "생성, 가공, 소비"의 구조로 이루어져 있다.
  - 스트림으로 들어온 데이터는 여러 중간연산 과정을 거쳐 종결 연산이 수행된다.
  1. 스트림 생성
     - 데이터의 집합인 컬렉션이나 배열등을 스트림으로 변환하는 과정
     - 스트림 파이프라인에서 가장 처음 실행되어야 한다.
     - 생성 단계에서 모든것을 메모리에 로드 하지않고, 필요할 때 로드한다. 따라서 메모리 사용량을 최적화할 수 있다.
  2. 가공(중간 연산)
     - 데이터 집합을 원하는 형태로 가공하는 과정이다.
     - 데이터 집합을 대상으로 필터, 변형, 정렬등의 연산을 수행한다.
     - 중간 연산은 스트림의 메서드이며, 연산 결과도 스트림이다. 그래서 메서드 체이닝을 유지할 수 있다.
  3. 소비(종결 연산)  
     - 데이터 집합에 대한 최종적인 결과물을 얻는 과정
     - 종결 연산은 딱 한 번만 수행할 수 있다. 종결 연산이 수행되면 스트림이 닫혀서 더 이상 중간 연산이나 종결 연산을 할 수 없다.

* 스트림(Stream)을 생성 하는 방법
  1. 컬렉션 객체에서 스트림 생성
    - java.util.Collection<E> 인터페이스의 `stream<타입 매개 변수>` 메서드로 생성한다. 
        ```
        public interface Collection<E> extends Iterable<E> {
            ...
            default Stream<E> stream() {
                return StreamSupport.stream(spliterator(), false);
            }
            ...
        } 
        List<String> names = Arrays.asList("Kim", "Yoon", "Park");
        Stream<String> stream = names.stream();
  2. 배열에서 스트림 생성 
    - java.util.Arrays 클래스의 stream 메서드나 java.util.stream.Stream<T> 인터페이스의 of 메서드로 생성
        ``` 
        String[] names = { "Kim", "Yoon", "Park" };
        Stream<String> stream1 = Arrays.stream(names);
        Stream<String> stream2 = Stream.of(names);
        Stream<String> stream3 = Stream.of("Kim", "Yoon", "Park");
        int[] numbers = { 1, 2, 3, 4, 5 };
        IntStream intStream = Arrays.stream(numbers);
  3. 원시 자료형 스트림
    - IntStream, LongStream, DoubleStream 인터페이스는 int, long, double 자료형 값을 박싱하지 않고자료형 값 그대로 다루는 스트림을 나타낸다.
    - java.util.Arrays 클래스의 정적 메서드인 stream 메서드의 인자로 원시 자료형 배열을 지정하면 원시 자료형 스트림을 생성한다.
    - IntStream, LongStream, DoubleStream 인터페이스의 정적 메서드인 range 메서드나 rangeCloed
  4. 난수(임의의 수)를 만드는 원시 자료형 스트림
    - java.util.Random 클래스의 ints 메서드, longs 메서드, doubles 메서드로, 지정한 자료형의 난수를 만드는 무한한 원시 자료형 스트림을 생성할 수 있다.  
  5. 문자열에서 스트림 생성
    - String 클래스의 chars 메서드로 IntStream으로 생성한다.
    - java.util.regex.Pattern 클래스의 splitAsStream 메서드로 스트림을 생성한다.
  6. java.util.stream.Stream<T> 인터페이스의 generate 메서드로 무한 스트림 생성
    - generate 메서드의 인자는 Supplier 함수 인터페이스의 함수 객체이며, 인자로 주어진 함수 객체가 반환하는 값으로 무한한 스트림을 생성한다.
    - Stream<T> 인터페이스의 limit 메서드로 스트림의 요소 개수를 제한할 수 있다.
  7. java.util.stream.Stream<T> 인터페이스의 iterate 메서드로 무한 스트림 생성
    - 인자로 2개의 값이 들어가는데 첫 번째 인자는 초깃값 두 번째 인자는 함수형 인터페이스 이다.
  8. 두 스트림을 연결해서 새로운 스트림을 생성
     - Stream<T> 인터페이스의 정적 메서드인 concat 메서드로 두 스트림을 연결해서 새로운 스트림을 생성한다.
  9. 빈 스트림 생성
     - Stream<T> 인터페이스의 empty 메서드로 빈 스트림을 생성한다.(요소가 없는 스트림이다.)
  10. 빌더 스트림 생성 
     - Stream 인터페이스의 정적 메서드인 builder 메서드로 빌더 패턴을 사용해 스트림을 생성한다.
     * 파일 내용으로 스트림 생성
       - java.nio.file.Files 클래스의 lines 메서드로 파일 내용으로 스트림을 생성한다.