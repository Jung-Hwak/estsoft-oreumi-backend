# JPA 영속 계층 구현 및 CRUD 테스트 (2026-01-21)

## 1. 엔티티(Entity) 설계와 빌더 패턴

### 1. 엔티티 클래스 구조
* **@Entity:** 클래스를 DB 테이블과 매핑되는 핵심 객체로 선언함.
* **@Id & @GeneratedValue:** 기본키(PK)를 지정하고 `IDENTITY` 전략을 통해 DB의 자동 증가 기능을 활용함.
* **@Builder:** 빌더 패턴을 적용하여 복잡한 생성자 대신 가독성 좋고 안전하게 엔티티 인스턴스를 생성함.

### 2. 필드 및 감사(Auditing) 설정
* **Setter 지양:** 무분별한 `set...` 대신 `updateTitle` 등 의도가 명확한 식별자를 사용해 설정자를 작성함.
* **자동 시각 기록:** `@CreationTimestamp`와 `@UpdateTimestamp`를 사용하여 데이터의 생성 및 수정 시각을 자동으로 관리함.

---

## 2. Spring Data JPA 리포지토리

### 1. 리포지토리 인터페이스 구조
* **JpaRepository<T, ID>:** 기본적인 CRUD 및 페이징, 정렬 기능을 포함한 최상위 인터페이스임.
* **작동 원리:** 인터페이스만 정의하면 스프링이 실행 시점에 동적으로 구현체 인스턴스를 빈(Bean)으로 생성하여 주입함.

### 2. 쿼리 생성 방법
* **쿼리 메서드:** `findByWriter`와 같이 규칙에 맞게 메서드명을 지으면 JPA가 식별자를 분석하여 SQL을 자동 생성함.
* **@Query:** 복잡한 SQL이 필요한 경우 직접 JPQL이나 SQL을 작성하여 실행함.
* **Named Query:** 엔티티에 미리 쿼리를 정의해두고 리포지토리에서 식별자를 통해 호출함.

---

## 3. Optional과 함수형 인터페이스

### 1. Optional<T> 처리
* **도입 배경:** DB 조회 결과가 null일 때 발생하는 `NullPointerException`을 방지하기 위한 래퍼 클래스임.
* **핵심 메서드:** * `orElseThrow()`: 값이 없으면 예외를 던지고, 있으면 즉시 값을 반환함.
    * `ifPresentOrElse()`: 값의 유무에 따라 각각 실행할 로직(Consumer, Runnable)을 인자로 받음.

### 2. 함수형 프로그래밍 기초
* **람다(Lambda):** 익명 클래스 대신 간결한 문법으로 함수형 인터페이스의 로직을 정의함.
* **핵심 인터페이스:** `Consumer`(매개변수 O, 반환 X), `Supplier`(매개변수 X, 반환 O), `Runnable`(매개변수 X, 반환 X).

---

## 4. 영속 계층 CRUD 테스트 

### 1. Create & Read 테스트
* **저장(Save):** 빌더로 생성한 엔티티를 저장하며, 저장 후 반환된 객체에서 할당된 PK(ID)를 확인함.
* **조회(Read):** `findById()`로 조회한 `Optional` 객체에서 안전하게 엔티티를 추출하여 필드 값을 검증함.

### 2. Update & Delete 테스트
* **수정(Update):** `조회 → 엔티티 메서드 호출(값 변경) → save()` 순서로 진행함.
* **Dirty Checking:** 영속성 컨텍스트 내의 엔티티는 변경 사항을 감지하여 트랜잭션 종료 시 자동으로 반영함.
* **삭제(Delete):** `deleteById()` 등을 사용하여 특정 레코드를 제거함.